---
layout: post
title: “CPU configuration and operation”
date: 2022-08-03 22:30:00 +0530
categories: CPU
---

<br>

## 1. CPU의 구성과 동작
### 1.1 CPU의 기본 구성
CPU는 명령어를 해석하여 실행하는 장치로 산술논리 연산장치, 제어장치, 레지스터로 구성되어 협업으로 작업을 처리한다. <br>
**산술논리 연산장치** <br>
CPU에서 데이터를 연산하는 장치가 산술논리 연산장치(*Arithmetic and Logic Unit, ALU*)이다. 산술논리 연산장치에는 데이터의 덧셈, 뺄셈, 곱셈, 나눗셈 같은 산술 연산과 AND, OR 같은 논리 연산을 수행한다. <br>
**제어장치** <br>
CPU에서 작업을 지시하는 부분을 제어장치(*Control Unit*)라고 한다. <br>
**레지스터** <br>
CPU 내에 데이터를 임시로 보관하는 곳을 레지스터(*Register*)라고 한다. <br>

### 1.2 CPU의 명령어 처리 과정
**소스코드 2-1 : C 언어로 작성한 덧셈 프로그램** <br>

```c
int D2=2, D3=3, sum;
sum=D2+D3;
```

CPU는 0과 1의 진수로 이루어진 기계어(*machine code*)만 인식한다. 따라서 위 코드를 실행하려면 컴파일러를 이용하여 기계어로 바꾸어야 한다. 
아래 어셈블리어는 기계어를 사람이 이해하기 쉬운 기호와 일대일로 대응시켜 기호화한 언어이다.
<br>
[소스코드 2-2]는 위 코드를 어셈블리어로 변환한 것이다. D2는 메모리의 100번지, D3은 120번지, sum은 160번지를 가리킨다고 가정한다. 어셈블리어에서 LOAD는 가져오기, ADD는 더하기, MOVE는 옮기기 명령어이며 
register 1은 레지스터 1을, mem(100)은 메모리의 100번지를 의미한다. <br>

**소스코드 2-2 : 어셈블리어로 변환한 덧셈 프로그램**

```
LOAD mem(100), register 2;
LOAD mem(120), register 3;
ADD register 5, register 2, register 3;
MOVE register 5, mem(160);
```

- 01행: 메모리의 100번지(D2)에 있는 값을 레지스터 2로 가져온다.
- 02행: 메모리의 120번지(D3)에 있는 값을 레지스터 3으로 가져온다.
- 03행: 레지스터 2와 레지스터 3에 저장된 값을 더한 결과를 레지스터 5에 넣는다.
- 04행: 레지스터 5의 값을 메모리의 160번지(sum)로 옮긴다.

CPU가 연산을 하려면 필요한 데이터를 CPU로 가져와 임시로 보관해야 하는데, 이때 사용되는 장소가 레지스터이다. <br>
<br>
제어장치는 명령어를 해석하여 제어신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할을 한다. 위의 예에서 제어장치는 '메모리에서 데이터를 가져와라',
'덧셈을 실행하라', '덧셈한 결과값을 메모리로 옮겨놓아라'라고 신호를 보낸다.

### 1.3 레지스터의 종류
CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장하고 산술논리 연산장치를 이용하여 연산을 한 후, 그 결과를 다시 레지스터에 저장했다가 메모리로 옮긴다. 
이때 사용되는 레지스터는 데이터 레지스터와 주소 레지스터이다.
데이터 레지스터와 주소 레지스터는 사용자 프로그램에 의해 변경되기 때문에 가시 레지스터(*user-visible register*)라고 부른다. <br>
- 데이터 레지스터(*DR*): 데이터 레지스터(*data register*)는 메모리에서 가져온 데이터를 임시로 보관할 때 사용한다. CPU에 있는 대부분의 레지스터이기 때문에 일반 레지스터 또는 범용 레지스터라고 부른다.
- 주소 레지스터(*AR*): 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터(*address register*)에 저장된다.
<br>

이 외에도 특별한 용도로 사용되는 특수 레지스터도 있는데, 특수 레지스터는 사용자가 임의로 변경할 수 없기 때문에 사용자 불가시 레지스터(*user-invisible register*)라고 부른다.
특수 레지스터에는 다음과 같은 종류가 있다. <br>
- 프로그램 카운터(*PC*): CPU는 다음에 어떤 명령어를 처리해야 할지 알아야 한다. [소스코드 2-2]의 경우 01행을 처리한 후 02행을 처리해야 한다는 사실을 알아야 한다. 프로그램 카운터(*Program Counter*)는 다음에 실행할
명령어의 주소를 기억하고 있다가 제어장치에 알려준다. 다음에 실행할 명령어의 주소를 가리키기 때문에 명령어 포인터(*instruction pointer*)라고도 한다.
- 명령어 레지스터(*IR*): 명령어 레지스터(*instrcution register*)는 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.
- 메모리 주소 레지스터(*MAR*): 메모리 주소 레지스터(*memory address register*)는 메모리에서 데이터를 가져오거나 반대로 메모리를 데이터로 보낼 때 주소를 지정하기 위해 사용한다. 
명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 이를 인식하여 해당 메모리의 위치를 가져오거나 해당 메모리 위치에 데이터를 저장한다.
- 메모리 버퍼 레지스터(*MBR*): 메모리 버퍼 레지스터(*memory buffer register*)는 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장한다. 
메모리 버퍼 레지스터는 항상 메모리 레지스터와 함께 동작한다.
<br>
[소스코드 2-2]의 01행인 'LOAD mem(100), register 2;'의 실행 과정을 통해 특수 레지스터의 역할을 살펴보자. <br>

1. 프로그램 카운터에는 현재 실행 중인 코드의 행 번호 1이 저장되고 이 번호는 제어장치에 전송된다. 명령어 레지스터에는 'LOAD' mem(100), register 2;'의 LOAD가 탑재된다.
2. 제어장치가 명령어 레지스터에 있는 명령을 해석하여 메모리에 있는 데이터를 가져오라는 제어 신호를 보낸다. 
3. 메모리 주소 레지스터에는 100이 저장되고, 메모리 관리자는 메모리의 100번지에 저장된 값을 메모리 버퍼 레지스터로 가져온다.
4. 제어 장치는 메모리 버퍼 레지스터에 저장된 값을 레지스터 2로 옮긴다.

<br>

이 외에도 CPU가 사용하는 레지스터는 다양하다. <br>
프로그램 상태 레지스터(*Program Status Register, PSR*)는 산술논리 연산장치와 연결되어 있으며 연산 결과가 양수인지, 음수인지, 0이 아닌지 또는 자리 올림의 유무 등을 저장한다.
프로그램 상태 레지스터는 플래그 레지스터(*flag register*), 상태 레지스터(*status register*), 컨디션 레지스터(*condition register*)라고도 한다.
<br>

**소스코드 2-3 : 분기 조건이 있는 프로그램** <br>

```
if(D2-D3 > 0)
    goto 100;
else
    goto 200;
```

위 코드에서 D2-D3의 결과는 if 문장의 분기 조건이므로 다음 연산 순서에 영향을 미친다.
D2-D3의 결과가 양수이면 코드의 100번 행으로, 음수이면 200번 행으로 가야 한다. 프로그램 상태 레지스터는 D2-D3의 결과를 임시로 저장하고 있다가 음수인지 양수인지를 
제어 장치에 알려주어 다음에 몇 번 행으로 이동할지를 결정한다. <br>

<table>
  <tr>
    <td colspan="2">레지스터</td>
    <td>특징</td>
  </tr>
  <tr>
    <td rowspan="2">사용자 가시 레지스터</td>
    <td>데이터 레지스터(DR)</td>
    <td>CPU가 명령어를 처리하는 데 필요한 일반 데이터를 임시로 저장한느 범용 레지스터 이다.</td>
  </tr>
  <tr>
    <td>주소 레지스터(AR)</td>
    <td>데이터 또는 명령어가 저장된 메모리의 주소를 저장한다.</td>
  </tr>
  <tr>
    <td rowspan="5">사용자 불가시 레지스터</td>
    <td>프로그램 카운터(PC)</td>
    <td>다음에 실행할 명령어의 위치 정보(코드의 행 번호, 메모리 주소)를 저장한다.</td>
  </tr>
  <tr>
    <td>명령어 레지스터(IR)</td>
    <td>현재 실행 중인 명령어를 저장한다.</td>
  </td>
  <tr>
    <td>메모리 주소 레지스터(MAR)</td>
    <td>메모리 관리자가 접근해야 할 메모리의 주소를 저장한다.</td>
  </td>
    <tr>
    <td>메모리 버퍼 레지스터(MBR)</td>
    <td>메모리 관리자가 메모리에서 가져온 데이터를 임시로 저장한다.</td>
  </td>
    <tr>
    <td>프로그램 상태 레지스터(PSR)</td>
    <td>연산 결과(양수, 음수 등)를 저장한다.</td>
  </td>
</table>

<br>

### 1.4 버스의 종류
버스는 CPU와 메모리, 주변장치 간에 데이터를 주고받을 때 사용한다. 버스에는 다음 작업을 지시하는 제어 신호, 메모리의 위치 정보를 알려주는 주소, 처리할 데이터가 오고 가며 각각 제어 버스, 주소 버스, 데이터 버스에 실린다. <br>
**제어 버스** <br>
제어 버스(*control bus*)에서는 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
메모리에서 데이터를 가져올지, 처리한 데이터를 옮겨놓을지에 대한 지시 정보가 오고가는데, 메모리에서 데이터를 가져올 때는 읽기 신호를 보내고, 처리한 데이터를 메모리로 옮겨 놓을때는 쓰기 신호를 보낸다. 제어 버스는 CPU의 제어장치와 연결되어 있다. 
메모리에서 오류가 발생하거나 네트워크 카드에 데이터가 모두 도착했다는 신호는 모두 제어 버스를 통해 CPU로 전달된다.
제어 버스의 신호는 CPU, 메모리, 주변장치와 양방향으로 오고 간다. <br>
**주소 버스** <br>
주소 버스(*address bus*)에서는 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지를 알려주는 위치 정보(주소)가 오고 간다. 주변장치의 경우도 하드디스크의 어느 위치에서 데이터를 읽어올지, 어느 위치에 저장할지에 대한 위치 정보가 주소 버스를 통해 전달된다. 주소 버스는 메모리 주소 레지스터와 연결되어 있으며 단방향이다. CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없다. <br>
**데이터 버스** <br>
제어 버스가 다음에 어떤 작업을 할지 신호를 보내고 주소 버스가 위치 정보를 전달하면 데이터가 데이터 버스(*data bus*)에 실려 목적지까지 이동한다. 데이터 버스는 메모리 버퍼 레지스터와 연결되어 있으며 양방향이다. <br>

|버스|특징|
|---|---|
|제어 버스|제어장치와 연결된 버스로, CPU가 메모리와 주변장치에 제어 신호를 보내기 위해 사용한다. 메모리와 주변장치에서도 작업이 완료되거나 오류가 발생하면 제어 신호를 보내기 때문에 양방향이다.|
|주소 버스|메모리 주소 레지스터와 연결된 버스로, 메모리나 주변장치에 데이터를 읽거나 쓸 때 위치 정보를 보내기위해 사용하며 단방향이다.|
|데이터 버스|메모리 버퍼 레지스터와 연결된 버스로, 데이터의 이동이 양방향으로 이루어진다.|

<br>

버스의 대역폭(*bandwidth*)은 한 번에 전달할 수 있는 데이터의 최대 크기를 말한다.
버스의 대역폭은 CPU가 한 번의 처리할 수 있는 데이터의 크기와 같다. 예를 들어 32bit CPU는 CPU가 한번에 처리할 수 있는 최대 크기가 32bit이다. 32bit CPU는 메모리에서 데이터를 읽거나 쓸 때 한 번에 최대 32bit를 처리할 수 있으며, 이 경우 레지스터의 크기도 32bit, 버스의 대역폭도 32bit이다. 버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장할 수 있는 데이터의 크기는 항상 같다. CPU가 한 번에 처리할 수 있는 데이터의 최대 크기를 워드(*word*)라고 하며, 버스의 대역폭과 메모리에 한 번에 저장되는 단위도 워드이다. 32bit CPU에서 1워드는 32bit이다.
<br><br><br>
출처: (한빛미디어)(쉽게 배우는 운영체제)