---
layout: post
title: “OperatingSystem Overview”
date: 2022-08-08 12:30:00 +0530
categories: OS OperatingSystem Overview
---

<br>

## 운영체제 개요

프로그램이 하는 일: 명령어를 실행하고 프로세스는 명령어를 초당 수십억씩 반입(fetch)하고, 해석(decode)하고, 실행(execute)한다.
명령어 작업을 완료한 후 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다. <br>

이것이 **Von Neumann**의 컴퓨터 모델의 기초이다. <br>

운영체제(_Operating System, OS_)란 프로그램을 쉽게 실행하고, 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 일을 할 수 있게 하는 소프트웨어이다. <br>

운영체제는 이러한 일을 하기위해 가상화(_Virtualization_)라는 기법을 사용한다.
운영체제는 프로세서, 메모리, 디스크와 같은 물리적(_Physical_)인 자원을 이용하여 일반적이고, 강력하고, 사용이 편리한 가상(_Virtual_)형태의 자원을 생성한다. 때문에 운영체제를 때로는 가상 머신(_Virtual Machine_)이라고 부른다.
사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관한 기능들을 운영체제에 요청할 수 있도록, 운영체제는 사용자에게 API를 제공한다. 보통 운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜**을 제공한다. 운영체가 프로그램 실행, 메모리와 장치에 접근, 기타 이와 관련된 여러 작업을 진행하기 위해 이러한 시스템 콜을 제공하기 때문에, 운영체제가 표준 라이브러리(_standard library_)를 제공한다고 일컫기도 한다. <br>

가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 한다. 프로그램들이 각자 명령어와 데이터를 접근할 수 있게 하며 디스크 등의 장치를 공유할 수 있게 한다.
이러한 이유로 운영체제는 **자원 관리자(_resouce manager_)**라고도 불린다. CPU, 메모리, 및 디스크는 시스템의 자원이다. 효율적으로 공정하게, 이들 자원을 관리하는 것이 운영체제의 역할이다.

## CPU 가상화

그림 2.1의 프로그램이 하는 일은 Spin()을 호출하는 것이다. Spin()은 1초 동안 실행된 후 리턴하는 함수이다. 그런 후 사용자가 명령어 라인으로 전달한 문자열을 출력한다. 이러한 일련의 작업을 무한히 반복한다. <br>

이 코드를 cpu.c라는 이름으로 저장하고 단일 프로세서(_CPU_) 시스템에서 컴파일하고 실행시키면 다음과 같은 출력을 볼 수 있다.

**그림2.1 반복해서 출력하는 코드(cpu.c)** <br>

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/tim.h>
#include <assert.h>
// #include "common.h"
int
main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit (1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
```

![cpu_1](/../image/ostep/cpu_1.png)
![cpu_2](/../image/ostep/cpu_2.png)

시스템은 프로그램 실행 후 1초가 지나면 사용자가 전달한 입력 문자열을 출력한다. 출력 후 실행을 계속한다. 이때 프로그램은 계속 실행된다.<br>
그림 2.2에서는 같은 작업에 대한 여러 인스턴스를 동시에 실행시켰다.
프로세서가 하나밖에 없음에도 프로그램 4개 모두 동시에 실행되는 것처럼 보인다. 하드웨어의 도움을 받아 운영체제가 시스템에 수많은 가상 CPU가 존재하는 듯한 환상(_illusion_)을 만들어 냈다.
하나의 CPU 또는 소규모 CPU 집합을 무한개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것을 CPU 가상화(_virtualizing the CPU_)라 한다. <br>

프로그램을 실행하고, 멈추고, 어떤 프로그램을 실행시킬 것인가를 운영체제에게 알려주기 위해서는 원하는 바를 운영체제에 전달할 수 있는 인터페이스(_API_)가 필요하다.
API는 운영체제와 사용자가 상호작용할 수 있는 주된 방법이다. <br>

다수의 프로그램을 동시에 실행시킬 수 있는 기능은 새로운 종류의 문제를 발생시킨다. 특정 순가에 두 개의 프로그램이 실행되기를 원한다면, 누가 실행되어야 하는가?
이 질문은 운영체제의 정책(_policy_)에 달려있다. 운영체제가 구현한 동시에 다수의 프로그램을 실행시키는 **기본적인 기법(_mechanism_)**인 **자원 관리자**로서의 운영체제의 역할을 확인해볼 수 있다. <br><br>

## 메모리 가상화

**물리 메모리(_physical memory_)** 모델은 매우 단순하다. 바이트의 배열이다. 메모리를 읽기 위해서는 데이터에 **(_주소_)**를 명시해야 한다. 메모리에 **쓰기(갱신)** 위해서는 주소와 데이터를 명시해야 한다. <br>
메모리는 프로그램이 실행되는 동안 항산 접근된다. 프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load와 store 또는 기타 메모리 접근을 위한 명령어를 통하여 자료 구조에 접귾나다. 명령어 역시 메모리에 존재하며 명령어를 반입할 때마다 메모리가 접근된다. <br>
다음 그림은 malloc()을 호출하여 메모리를 할당하는 프로그램이다.

```C
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
int main (int argc, char *argv[]){
    int *p = malloc (sizeof (int)); // a1
    assert (p != NULL);
    printf (" (%d) memory address of p: %p\n", getpid(), (unsigned) p); // a2
    *p = 0; //a3
    while (1) {
        Spin(1);
        *p = *p + 1;
        printf(" (%d) p: %d\n", getpid(), *p); // a4
    }
    return 0;
}
```

![mem_1](/../image/ostep/mem_1.png)
![mem_2](/../image/ostep/mem_2.png)

먼저 메모리를 할당받는다.(a1 행)<br>
할당 받는 메모리의 주소를 출력한다.(a2 행)<br>
새로 할당받은 메모리의 첫 슬롯에 숫자 0을 넣는다.(a3 행)<br>
루프로 진입하여 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시킨다.
출력할 때마다 실행 중인 프로그램의 프로세스 식별자(PID)라 불리는 값이 함께 출력된다.(a4 행)
PID는 프로세스의 고유의 값이다. <br>
첫번째 실행 결과의 새로 할당된 메모리의 주소는 0×600001000030이다.
프로그램이 진행되면서 천천히 값을 갱신하고 그 결과를 출력한다.
같은 프로그램을 여러 번 실행시켜 보면 프로그램들은 같은 주소에 메모리를 할당받지만 (0x600002a3c030), 각각이 독립적으로 0x600002a3c030 번지의 값을 갱신한다. 각 프로그램은 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 각자 자신의 메모리를 가지고 있는 것처럼 보인다. <br>
운영체제가 **메모리 가상화(_virtualizing memory_)** 를 하기 때문에 이러한 현상이 생긴다.
각 프로세스는 자신만의 **가상 주소 공간(_virtual address space_)**, 때로 그냥 **주소 공간(_address space_)** 을 갖는다. 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 매핑(mapping)한다. 하나의 프로그램이 수행한느 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다. 실행 중인 프로그램의 입장에서는, 자기 자신만의 물리 메모리를 갖는 셈이다. 실제로는 물리 메모리는 공유 자원이고, 운영체제의 의해 관리된다. <br>

## 병행성

프로그램이 한 번에 만은 일을 하려 할 때(동시에) 발생하는, 반드시 해결해야 하는 문제들을 가리킬 때 **병행성(_concurrency_)**라는 용어를 사용한다. 병행성 문제는 우선 운영체제 자체에서 발생한다. 운영체제는 한 프로세스의 실행, 다음 프로세스, 또 다음 프로세스등의 순서로 여러 프로세스를 실행시켜 한번에 많은 일을 한다. 이러한 행동은 문제를 발생시킨다. <br>

병행성 문제는 운영체제만의 문제는 아니다. **멀티 쓰레드** 프로그램도 동일한 문제를 드러낸다. **멀티 쓰레드** 프로그램을 예로 들어 확인해보자.

```C
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "common_threads.h"
volatile int counter = 0;
int loops;
void *worker(void *arg){
    int i;
    for (i = 0; i < loops; i++){
        counter++;
    }
    return NULL;
}

int main(int argc, char *argv[]){
    if (argc != 2) {
        fprintf(stderr,"usage: thread <value>\n");
        exit(1);
    }
    loops = atoi(argv[1]);
    pthread_t p1, p2;
    printf("Initial value: %d\n", counter);

    Pthread_create(&p1, NULL, worker, NULL);
    Pthread_create(&p2, NULL, worker, NULL);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    printf("Final value: %d\n", counter);
    return 0;
}
```

메인 프로그램은 Pthread_create() 를 사용하여 두 개의 쓰레드를 생성한다. 쓰레드를 동일한 메모리 공간에서 함께 실행 중인 여러 개의 함수라고 생각할 수 있다. 예제 코드에서 각 쓰레드는 worker()라는 루틴을 실행한다. worker() 루틴은 loops번 만큼 루프를 반복하면서 카운터 값을 증가시킨다.
loops 값은 각 쓰레드가 카운터를 증가시키는 횟수다. loops 값을 1000으로 지정한 후 프로그램을 실행시키면, couter 변수의 최종 값은 얼마가 될까?

![thread_1](/../image/ostep/thread_1.png)

각 쓰레드가 1000번씩 couter값을 증가시켰기 때문에 couter의 최종 값은 2000이 된다. loops 값이 N이면 프로그램의 최종 출력은 2N이 될거라고 생각할 수 도있다.
이번에는 loops의 값을 더 큰 값으로 지정해 프로그램을 다시 실행시켜 보았다.

![thread_2](/../image/ostep/thread_2.png)

입력 값을 100,000으로 주었더니 최종 값이 200,000이 아닌 102,132가 되었다. 다시 한번 동일한 조건으로 실행시켰을 때에는 또 잘못된 값이 출력 되었을 뿐 아니라 직전 실행과도 다른 결과가 출력되었다. <br>

예상하지 못한 결과의 원인은 명령어가 한번에 하나씩만 실행된다는 것과 관련 있다. 앞 프로그램의 핵심 부분인 counter를 증가시키는 부분은 세 개의 명령어로 이루어진다. counter 값을 메모리에서 레지스터로 탑재하는 명령어 하나, 레지스터를 1 증가시키는 명령어 하나, 레지스터의 값을 다시 메모리에 저장하는 명령어 하나 이렇게 3개의 명령어로 구성된다. 이 세 개의 명령어가 **원자적(_atomically_)**으로(한 번에 3개 모두)실행되지 않기 때문에 이상한 일이 발생할 수 있다.<br>

## 목표

운영체제는 CPU, 메모리, 디스크와 같은 물리 **자원**을 **가상화(_virtualize_)**한다. 운영체제는 병행성과 관련된 복잡한 문제를 처리한다. 파일을 **영속적**으로 저장하여 아주 오랜 시간 동안 안전한 상태에 있게 한다.
가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 **개념(_abstraction_)**들을 정리하는 것이다. 추상화를 통해 큰 프로그램을 이해하기 쉬운 작은 부분들로 나누어 구현할 수 있다.
운영체제의 설계와 구현에 중요한 목표는 **성능**이다. **오버헤드를 최소화(_minimize the overhead_)**하는 것이다.
또 다른 목표는 응용 프로그램 간의 **보호**, 운영체제와 응용 프로그램 간의 **보호**이다.
보호는 운영체제의 원칙 중 하나인 **고립(_isolation_)** 원칙의 핵심이다.
또한 높은 수준의 **신뢰성(_reliability_)**을 제공해야 한다.

<br><br><br>
출처: 운영체제 아주쉬운 세 가지 이야기(도서출판 홍릉), [KAIST-OSLab] [참조1]

[참조1]: https://oslab.kaist.ac.kr/OSTEPSlides/
